\documentclass[]{article}

%opening
\title{}
\author{}

\begin{document}
	

<<setup, include=FALSE>>=
library(knitr)
library(cowplot) # styling of plots, extension of ggplot2
library(gridExtra) # grid layouts for ggplot2
library(lattice) # needed for bwplot etc

opts_chunk$set(fig.path='generated_figures/')
knit_hooks$set(pdfcrop = hook_pdfcrop)


a = read.csv('population-toyworld2.csv', header=FALSE)
unique_species = read.csv('species-toyworld2.csv', header=FALSE)
# Bedau1998, Channon2006
delta_c = a
delta_p = data.frame(apply(a, 2, function(c) ifelse(c==0,0,1)))
evolutionary_activity_p = cumsum(delta_p)
evolutionary_activity_c = cumsum(delta_c)

# Bedau1998, Channon2006
diversity = apply(delta_p, 1, sum)
mean_cumulative_evolutionary_activity_p = apply(evolutionary_activity_p, 1, sum) / diversity
mean_cumulative_evolutionary_activity_c = apply(evolutionary_activity_c, 1, sum) / diversity

# Bedau1998, Channon2006
a0 = 1
a1 = 5
new_function = function(x) sum(x[which(x >= a0 & x <= a1)])
new_evolutionary_activity_p = apply(evolutionary_activity_p, 1, new_function) / diversity
new_evolutionary_activity_c = apply(evolutionary_activity_c, 1, new_function) / diversity


length_longest_nondecreasing_sequence <- function(x) {
  nondecreasing_sequences <- x[2:length(x)] >= x[1:length(x)-1]
  nondecreasing_sequences <- x[2:length(x)] != 0 & nondecreasing_sequences # only those runs where the count > 0
  runs <- rle(nondecreasing_sequences)
  max(runs$lengths[which(runs$values==TRUE)])
}

llns <- apply(delta_c,2,length_longest_nondecreasing_sequence)


# https://www.researchgate.net/post/What_is_the_queue_data_structure_in_R

{
new.queue <- function() {
ret <- new.env()
ret$front <- new.env()
ret$front$q <- NULL
ret$front$prev <- NULL
ret$last <- ret$front
return(ret)
}

## add to end of queue
enqueue <- function(queue, add){
queue$last$q <- new.env()
queue$last$q$prev <- queue$last
queue$last <- queue$last$q
queue$last$val <- add
queue$last$q <- NULL
}

## return front of queue and remove it
dequeue <- function(queue){
if (is.empty(queue)) {
stop("Attempting to take element from empty queue")
}
value <- queue$front$q$val
queue$front <- queue$front$q
queue$front$q$prev <- NULL
return(value)
}

is.empty <- function(queue){
return(is.null(queue$front$q))
}
}

N = 10
qq <- new.queue()
for(i in 1:N){
enqueue(qq,i)
}

while (! is.empty(qq)) {
print(dequeue(qq))
}

## This work is licensed under the Creative Commons
## Attribution-ShareAlike 3.0 Unported License. To view a copy of this
## license, visit http://creativecommons.org/licenses/by-sa/3.0/ or send
## a letter to Creative Commons, 171 Second Street, Suite 300, San
## Francisco, California, 94105, USA.
##
## (c) Copyright Barry Rowlingson 2010
## B.Rowlingson@lancaster.ac.uk

queue = function(statistics=FALSE){
	###
	### queue implmentation (c) Barry Rowlingson 2010
	###
	### creates a queue object. the 'statistics' flag adds basic logging
	###
	e=new.env()
	q=list()
	assign("q",q,envir=e)
	assign("stats",NULL,envir=e)
	if(statistics){
		assign("stats",list(maxsize=0,on=0,off=0,minsize=0),envir=e)
	}
	class(e)=c("queue","environment")
	e
}

getStats = function(eq){
	### get the statistics from the queue
	return(get("stats",eq))
}

resetStats=function(eq){
	### reset the statistics from the queue
	q=get("q",envir=eq)
	m=list(maxsize=length(q),minsize=length(q),on=0,off=0)
	assign("stats",m,envir=eq)
	return(m)
}

### S3 Generic Functions
enqueue=function(eq,v){UseMethod("enqueue")}
dequeue=function(eq,v){UseMethod("dequeue")}

enqueue.queue=function(eq,v){
	###
	### S3 Method for adding a value 'v' to the queue
	###
	## add the value to the list
	q=c(v,get("q",envir=eq))
	## stick the list back in the environment
	assign("q",q,envir=eq)  
	
	## process the statistics if they're there:
	if(length({m=getStats(eq)})>0){
		m$on=m$on+1
		if(length(q)>m$maxsize){
			m$maxsize=length(q)
		}
		assign("stats",m,envir=eq)
	}
	
	## may as well return something, so here's the value back
	v
}


dequeue.queue=function(eq){
	###
	### S3 Method for taking something off the list
	###
	## get the queue, check if anything on it:
	q=get("q",envir=eq)
	if(length(q)==0){
		stop("Attempt to take element from empty queue")
	}
	
	## take the last value
	v=q[[length(q)]]
	
	## take the last value off:
	if(length(q)==1){
		assign("q",list(),eq)
	}else{      
		assign("q",q[1:(length(q)-1)],eq)
	}
	## update stats
	if(length({m=getStats(eq)})>0){
		m$off=m$off+1
		if(length(get("q",envir=eq))<m$minsize){
			m$minsize=length(q)-1
		}
		assign("stats",m,envir=eq)
	}
	return(v)
}

### print method
print.queue=function(x,...){
	print(get("q",envir=x))
}

summary.queue=function(object,...){
	cat("Queue object with ",length(get("q",envir=object))," elements\n")
	if(length({m=getStats(object)})>0){
		cat(m$on,"added,",m$off,"removed. min/max size=",m$minsize,"/",m$maxsize,"\n")
	}
	
}

queueTest=function(){
	q = queue(TRUE)
	for(i in 1:10){
		enqueue(q,i)
	}
	summary(q)
	resetStats(q)
	for(i in 1:5){
		dequeue(q)
	}
	summary(q)
	for(i in 1:10){
		enqueue(q,letters[i])
	}
	summary(q)
}

q = queue(TRUE)
for each reactant in reactants {
	enqueue(q, reactant)
}

while q is not empty {
	reactant = dequeue(q)
	find all reactions where reactant in reactants
		foreach product of reaction {
			if count[product] not known (not seen before) {
				parent[product] = reaction
				count[product] = 1
				enqueue(q, product)
			else 
				count[product] += 1
					
}

@

<<unboundedplot, pdfcrop=TRUE, echo=FALSE, cache=TRUE, warning=FALSE, fig.pos='htp', fig.scap=NA, fig.cap='Mean cumulative evolutionary activity.'>>=
c = data.frame(mean_cumulative_evolutionary_activity_c)
ggplot(data=c) + geom_point(aes(x=1:nrow(c), y=c$mean_cumulative_evolutionary_activity_c))

c = data.frame(new_evolutionary_activity_c)
ggplot(data=c) + geom_point(aes(x=1:nrow(c), y=c$new_evolutionary_activity_c))
@

\section{}

\end{document}


